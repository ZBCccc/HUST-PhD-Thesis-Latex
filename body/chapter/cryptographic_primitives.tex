\chapter{预备知识}
本章介绍本文所涉及的多用户多关键词可搜索对称加密基础构造及相关密码学预备知识，为后续章节的可验证机制设计与安全性论证提供统一的系统模型、符号体系与技术背景。按照章节安排，首先给出系统实体、交互流程与威胁假设，并明确本文所关注的泄露边界与安全目标。随后概述一类具有代表性的结构化索引型多用户多关键词 SSE 基础方案，说明其索引组织方式、搜索流程及典型泄露。接着讨论 Bloom Filter 在资格检验阶段的常见用法与局限，指出其难以支撑确定性可验证性的原因。最后整理本文将频繁使用的密码学原语与数据结构，包括伪随机函数、哈希函数、Merkle Hash Tree 与承诺机制等，为后续算法描述与证明建立可复用的技术基座。\cite{bloom1970,merkle1979,naor1991}
\section{系统与威胁模型}
\subsection{符号约定与数据表示}
设安全参数为 $\lambda$，所有概率算法均在输入 $1^\lambda$ 时以多项式时间运行。记 $\mathsf{negl}(\lambda)$ 为可忽略函数。令 $\mathcal{C}$ 表示系统中的用户集合，授权用户记为 $\mathcal{C}=\{\mathsf{C}_1\dots\mathsf{C}_t\}$，其中数据拥有者记为 $\mathcal{D}$。云服务器记为 $\mathcal{S}$，负责存储外包后的密文与索引，并根据搜索令牌执行检索。在多读者单写者模型下，引入了可信管理实体 $\mathcal{G}$，下文称为\emph{授权管理方}，负责维护访问控制信息与协助生成搜索令牌。$\mathcal{G}$ 可以由 $\mathcal{D}$ 自身承担，也可以由独立的可信组件实现，其职责是维护访问控制信息、协助生成搜索令牌，并在更新阶段完成必要的密钥演化或辅助信息生成，用于避免多方写入带来的复杂一致性问题，同时便于描述用户撤权与令牌生成逻辑。\cite{cash2014}

外包数据库由文件集合 $\mathcal{D}=\{(\mathsf{id}_1,\mathsf{doc}_1),\ldots,(\mathsf{id}_N,\mathsf{doc}_N)\}$ 组成，其中 $\mathsf{id}_i$ 为唯一标识。对每个文件 $\mathsf{doc}_i$，通过分词或特征提取得到其关键词集合 $\mathcal{w}_i\subseteq \mathcal{W}$，$\mathcal{W}$ 表示全局关键词空间。本文主要考虑合取查询，令查询关键词集合为 $Q=\{w_1,\ldots,w_t\}$，其中 $t\ge 2$。在搜索语义上，目标结果集为
\begin{equation}
\mathsf{Res}(Q)=\{\mathsf{id}_i\mid \forall w\in Q,\; w\in\mathcal{W}_i\}.
\end{equation}
除非特别说明，文中 ``结果'' 指文件标识集合 $\mathsf{Res}(Q)$，文件内容的返回与解密属于外层数据访问流程。

为方便后续叙述，表\ref{tab:notation}给出本文常用符号的简要汇总。
\begin{table}[t]
\centering
\caption{常用符号约定}
\label{tab:notation}
\begin{tabular}{ll}
\hline
符号 & 含义\\
\hline
$\lambda$ & 安全参数\\
$\mathcal{D}$, $N$ & 外包文件集合及规模\\
$\mathsf{id}$, $\mathsf{doc}$ & 文件标识与文件内容\\
$\mathcal{W}$, $\mathcal{w}_i$ & 关键词空间及文件 $i$ 的关键词集合\\
$Q=\{w_1,\ldots,w_t\}$ & 合取查询关键词集合\\
$\mathcal{D}$, $\mathcal{G}$, $\mathcal{C}_i$, $\mathcal{S}$ & 数据拥有者、授权管理方、授权用户、云服务器\\
$\mathsf{TSet}$, $\mathsf{XSet}$ & 结构化 SSE 中的两类核心索引结构\\
\hline
\end{tabular}
\end{table}

\subsection{协议接口与执行流程}
一个多用户多关键词动态 SSE 方案通常由以下多项算法接口构成。

\textbf{初始化} $\mathsf{Setup}(1^\lambda)$：生成主密钥以及初始化状态，输出密钥 $\mathsf{K}$ ，初始客户端状态 $\mathsf{st}$以及初始化加密数据库 $\mathsf{EDB}$。

\textbf{更新} $\mathsf{Update}(\mathsf{K},\mathsf{st},\mathsf{op},\mathsf{id},\mathcal{W}_{\mathsf{id}})$：执行插入或删除等动态操作 $\mathsf{op}$，产生发送给服务器的更新消息，并更新本地状态 $\mathsf{st}$。

\textbf{令牌生成} $\mathsf{GenToken}(\mathsf{K},\mathsf{st},\mathsf{C}_i,Q)$：在访问控制策略允许的前提下，为用户 $\mathsf{C}_i$ 和查询 $Q$ 生成搜索令牌 $\tau$。在多用户模型中，该步骤通常由 $\mathsf{G}$ 协助完成，用于确保撤权用户无法获得有效令牌。

\textbf{搜索} $\mathsf{Search}(\tau,\mathsf{EDB})$：服务器在加密数据库 $\mathsf{EDB}$ 上执行搜索并返回加密结果 $\rho$。

\textbf{解密与验证} $\mathsf{Dec/Verify}(\mathsf{K},\mathsf{st},\tau,\rho)$：用户或 $\mathsf{G}$ 在本地对返回结果进行解密或一致性检查；在可验证扩展中，该步骤还包含对搜索完整性与正确性的验证。

上述接口刻画了本文后续描述中所需的最小交互框架。实际系统往往还包含密钥分发、审计、撤权同步等外围机制，但它们不影响本文关注的核心技术点。
\subsection{威胁假设与安全目标}
本文在威胁模型上区分\emph{隐私对抗}与\emph{正确性对抗}两类目标。

在隐私对抗方面，服务器 $\mathsf{S}$ 被视为外部对手，可观察其存储的加密数据库、索引结构及协议交互记录，并可在自适应策略下发起被动分析。SSE 方案一般不追求零泄露，而是在显式的泄露函数 $\mathcal{L}$ 下给出安全性，即对手从交互中获得的信息被限制为 $\mathcal{L}(\mathcal{D},Q,\text{updates})$ 所描述的内容。典型泄露包括搜索模式、访问模式与更新模式等，后续第\ref{sec:leakage}节将进一步说明。

在正确性对抗方面，本文允许服务器偏离协议执行，返回不完整、错误或伪造的搜索结果。该假设对应外包环境中常见的 ``恶意服务器'' 风险，也是本文引入可验证机制的直接动机。与之对应地，本文默认 $\mathcal{D}$ 与 $\mathcal{G}$ 按协议诚实执行，授权用户 $\mathsf{C}_i$ 不主动篡改协议消息。对于撤权用户，本文不考虑其与服务器串谋的强对抗情形，而将其能力抽象为无法获得新的有效令牌或密钥材料。

在此基础上，本文关注的安全目标可概括为三类。

其一是\emph{正确性}。当服务器诚实执行时，客户端解密后的输出应等于 $\mathsf{Res}(Q)$。

其二是\emph{隐私性}。在泄露函数 $\mathcal{L}$ 所限定的范围内，对手无法区分两组具有相同泄露的查询与更新历史。该目标通常采用基于模拟的安全定义表达。

其三是\emph{可验证性}。当服务器可能作恶时，客户端应能检测到结果集遗漏或伪造。为便于后续论证，这里给出可验证性的两项常用性质。

\textbf{完整性}：若服务器返回的结果 $\rho$ 通过验证，则其解密输出应包含 $\mathsf{Res}(Q)$。

\textbf{健全性}：若服务器返回的结果 $\rho$ 通过验证，则其解密输出应是 $\mathsf{Res}(Q)$ 的子集，并且不应包含与查询不匹配的标识。

在更强的定义中，完整性与健全性可合并为 ``验证通过当且仅当结果等于 $\mathsf{Res}(Q)$''，但在工程实现中常将遗漏与伪造分别建模，以便针对不同环节设计证明对象。

\subsection{泄露模型与讨论}
\label{sec:leakage}
在结构化 SSE 构造中，泄露通常可按阶段划分。初始化阶段的泄露 $\mathcal{L}_{\mathsf{Setup}}$ 常包含数据库规模信息，例如文件数 $N$、每个关键词的出现频次等的某种函数。更新阶段的泄露 $\mathcal{L}_{\mathsf{Update}}$ 常包含操作类型、更新频率及与访问模式相关的可链接信息。搜索阶段的泄露 $\mathcal{L}_{\mathsf{Search}}$ 往往至少包含搜索模式与访问模式，即同一查询是否重复出现以及返回结果集合的大小或内容的可链接表示。\cite{cash2014}

需要强调的是，泄露模型与可验证性目标在概念上相互独立。可验证机制旨在约束服务器返回结果的行为，并不必然扩大泄露。后续章节将以尽量不增加泄露为约束，讨论如何在资格检验与结果返回两个关键环节实现可验证增强。

\section{多用户多关键词 SSE 基础方案}
多用户多关键词 SSE 的核心挑战在于同时兼顾四点需求：合取查询的高效性、动态更新能力、多用户授权管理，以及可接受的泄露边界。近年来，交叉标签加密索引逐渐成为实践上主流的设计路线，其代表性思路可追溯到基于倒排索引的动态 SSE 与支持交叉标签验证的合取查询框架。\cite{cash2014}

为了便于理解后续章节的改进设计，本节以一类典型的交叉标签多关键词可搜索加密方案为例，介绍其核心思路。该类方案采用 ``候选枚举+逐项资格检验'' 的两阶段搜索策略：首先通过计数器快速定位一个候选文件集合，然后逐一验证每个候选是否满足所有查询条件。下文将从索引组织、搜索流程与多用户扩展三个方面对其进行概要说明，并将具体实现细节抽象为通用组件，以便为后续的可验证性增强提供统一的技术参照框架。

\subsection{结构化索引的基本组成}
设系统维护两类核心索引结构，记为 $\mathsf{TSet}$ 与 $\mathsf{XSet}$。

$\mathsf{TSet}$ 是加密多映射结构，用于将关键词映射到一组与之相关的文件标识。直观上，服务器在不知道关键词语义的情况下，仍可通过一个伪随机地址 ``定位'' 与某关键词相关的密文条目序列。每个条目通常包含一个加密的文件标识以及与更新相关的辅助字段，用于支持插入、删除或懒删除等策略。

$\mathsf{XSet}$ 是用于资格检验的辅助集合结构，存储与 ``关键词与文件标识'' 相关的短标签。其目标是支持服务器在枚举候选标识后，快速判断候选是否同时满足其它关键词条件。$\mathsf{XSet}$ 的元素一般为固定长度比特串，可通过哈希函数与伪随机函数从关键词和标识派生。

两类结构的分工可概括为：$\mathsf{TSet}$ 负责生成候选集合，$\mathsf{XSet}$ 负责对候选集合做交叉条件过滤。

\subsection{合取查询的搜索流程}
令查询为 $Q=\{w_1,\ldots,w_t\}$。为了降低搜索开销，服务器通常先以某个 ``主关键词'' 为入口枚举候选集合，然后对每个候选执行其余关键词的资格检验。具体流程可概述如下。

首先，$\mathcal{G}$ 根据关键词的频次估计或历史统计信息，从 $Q$ 中选取出现频次最小或更新次数最少的关键词作为主关键词 $w_s$。该选择的目的在于使候选集合规模尽可能小，从而降低后续资格检验成本。

其次，$\mathcal{G}$ 为主关键词生成令牌的一部分，使服务器能够在 $\mathsf{TSet}$ 中枚举与 $w_s$ 相关的加密条目。服务器解包每个条目得到候选标识 $\mathsf{id}$，形成候选集合 $\mathsf{Cand}(w_s)$。

最后，对于每个候选 $\mathsf{id}\in\mathsf{Cand}(w_s)$，服务器对其余关键词 $w_j\in Q\setminus\{w_s\}$ 逐一进行成员性检测。该检测通过将 $w_j$ 与 $\mathsf{id}$ 组合并计算相应交叉标签，查询该标签是否属于 $\mathsf{XSet}$ 来完成。若对所有 $w_j$ 检测均为真，则 $\mathsf{id}$ 被加入输出结果集。

该流程的关键是将合取查询的计算复杂度与 $|\mathsf{Cand}(w_s)|$ 相关联，从而将多关键词检索从 ``与数据库规模相关'' 降至 ``与最小频次关键词相关'' 的子线性开销。\cite{cash2014}

\subsection{多用户授权与令牌生成}
在多用户场景中，访问控制的基本要求是撤权用户无法继续搜索，授权用户只能获得权限范围内的查询能力。结构化 SSE 方案通常通过 $\mathsf{GK}$ 统一发放令牌来实现该目标。

一种常见做法是将 ``能否针对关键词 $w$ 生成有效令牌'' 视为授权判据。$\mathsf{GK}$ 保存访问控制列表或策略，并在 $\mathsf{TokenGen}$ 中对用户身份、时间窗口、撤权状态等进行检查。检查通过后，$\mathsf{GK}$ 才会利用主密钥材料为 $Q$ 生成令牌 $\tau$ 并发送给用户。这样，服务器即便被动观察令牌，也无法自行生成新的有效令牌。

为了减少 $\mathsf{GK}$ 的在线负担，文献中亦存在将部分令牌生成能力下放给客户端的设计，例如通过分层密钥、时间演化密钥或受控的令牌派生机制实现。本文不依赖于某一种特定授权实现，仅要求多用户模型中存在一条可信的 ``令牌发放路径''，以便后续将验证信息与令牌或索引绑定。

\subsection{基础方案的局限性}
尽管上述结构化 SSE 在效率与隐私方面取得了良好平衡，但其安全关注点主要落在 ``关键词与访问模式的泄露控制'' 上。若服务器被允许偏离协议，它仍可能在两个环节实施欺骗。

第一类风险发生在资格检验阶段。服务器可跳过部分资格检测、选择性漏检，或故意返回更小的结果集以降低开销，客户端在缺乏证据的情况下难以发现遗漏。

第二类风险发生在结果返回阶段。服务器可能伪造标识、返回与查询不匹配的条目，或在更新与删除存在的情况下返回陈旧结果。

因此，在多用户多关键词 SSE 场景中，如何在尽量不破坏既有搜索效率与泄露边界的前提下，增加对服务器行为的可验证约束，构成本文后续章节的核心研究问题。

\section{Bloom Filter 在资格检验中的应用及其局限性}
在合取查询的逐项资格检验阶段，服务器需要进行大量成员性检测。为了降低时间与存储开销，部分方案引入 Bloom Filter 作为概率型过滤器，在服务器端快速排除不可能满足条件的候选项。Bloom Filter 最初由 Bloom 提出，是一种以允许假阳性为代价换取高空间效率的数据结构。\cite{bloom1970}

\subsection{Bloom Filter 的基本原理}
Bloom Filter 由长度为 $m$ 的位数组 $\mathbf{B}$ 与 $k$ 个独立哈希函数 $h_1,\ldots,h_k$ 组成，$h_j:\{0,1\}^*\rightarrow \{1,\ldots,m\}$。插入元素 $x$ 时，置 $\mathbf{B}[h_j(x)]\leftarrow 1$ 对所有 $j\in\{1,\ldots,k\}$。查询元素 $x$ 时，若存在某个 $j$ 使得 $\mathbf{B}[h_j(x)]=0$，则可判定 $x$ 不属于集合；若对所有 $j$ 均有 $\mathbf{B}[h_j(x)]=1$，则判定 $x$ 可能属于集合。

Bloom Filter 不产生假阴性，但会产生假阳性。若位数组中已有 $n$ 个元素，忽略哈希相关性的近似分析给出假阳性概率
\begin{equation}
\Pr[\text{false positive}] \approx \left(1-e^{-kn/m}\right)^k.
\end{equation}
在给定 $m$ 与 $n$ 的情况下，取 $k\approx (m/n)\ln 2$ 可使假阳性概率接近最小。该性质使 Bloom Filter 特别适合在大规模集合上实现快速过滤。\cite{bloom1970}

\subsection{在资格检验阶段的典型用法}
在多关键词搜索中，服务器先通过主关键词枚举候选集合 $\mathsf{Cand}(w_s)$，再对每个候选标识检验其是否同时满足其它关键词。Bloom Filter 的常见用法是将 ``关键词与标识'' 的组合编码为元素 $x=\mathsf{Enc}(w,\mathsf{id})$ 并插入到某个过滤器中。搜索时，服务器先对过滤器进行快速查询，仅当过滤器判断为 ``可能存在'' 时才进行更昂贵的后续操作，例如访问 $\mathsf{XSet}$、解包加密条目或执行更强的验证。

该设计的收益主要体现在常数因子优化上。由于 Bloom Filter 查询仅涉及固定次数的哈希与位读取，其开销与数据库规模无关，适合作为 ``预过滤'' 组件减少无效候选带来的计算与通信成本。

\subsection{局限性分析}
Bloom Filter 的局限性在可验证搜索语境下尤为突出。

首先，Bloom Filter 的输出是概率性的。即便服务器声称某候选 ``通过过滤''，该结论也不构成确定性的正确性证据。客户端无法仅凭过滤结果区分真实匹配与假阳性，从而无法将过滤过程提升为可证明的资格检验。

其次，Bloom Filter 不携带可供验证的路径信息。服务器在搜索阶段是否对所有候选执行了过滤，是否按规定使用了正确的过滤器，客户端均缺乏可核查的证据。更进一步，即便客户端要求服务器返回若干位的位置值，服务器仍可伪造这些位，原因在于 Bloom Filter 本身缺少与整体状态绑定的认证承诺。

再次，动态更新会带来实现层面的不确定性。标准 Bloom Filter 不支持删除，需借助计数型 Bloom Filter 或分层过滤等改造才能实现动态性，而这些改造会引入额外状态与一致性风险，并进一步增加对服务器诚实行为的依赖。

综上，Bloom Filter 更适合作为面向效率的工程优化组件，难以直接承担 ``证明服务器行为正确'' 的职责。若目标包含确定性验证与可追责证据，则需要引入具备认证承诺能力的数据结构，例如以哈希承诺为根的 Merkle Hash Tree，从而为成员性判断提供可验证证明。\cite{merkle1979}

\section{密码学预备知识}
本节整理本文将使用的密码学原语与数据结构，重点强调其安全性质及与后续章节的关联。除特别说明外，本文默认所有密钥均为从 $\{0,1\}^\lambda$ 均匀采样得到。

\subsection{伪随机函数}
伪随机函数族 $\mathsf{F}:\{0,1\}^\lambda\times\{0,1\}^*\rightarrow\{0,1\}^\lambda$ 是结构化 SSE 中的关键工具，常用于从关键词派生伪随机地址、标签或令牌。

其安全性可用不可区分性刻画：对任意概率多项式时间对手 $\mathcal{A}$，令其可自适应查询一个黑盒函数 $\mathcal{O}$，$\mathcal{O}$ 要么是 $\mathsf{F}_K(\cdot)$，其中 $K\leftarrow\{0,1\}^\lambda$，要么是同输入域到同输出域的真正随机函数 $\mathsf{RF}(\cdot)$。若 $\mathcal{A}$ 区分两种情形的优势至多为 $\mathsf{negl}(\lambda)$，则称 $\mathsf{F}$ 为安全的 PRF。SSE 中的地址隐藏与令牌不可预测性通常依赖该性质。

\subsection{对称加密与认证}
结构化 SSE 需要在服务器端存储加密条目，使服务器能够枚举但无法获知明文内容。为此通常采用满足 IND CPA 的对称加密算法 $\mathsf{SE}=(\mathsf{Enc},\mathsf{Dec})$。在需要抵抗密文篡改时，还会结合消息认证码或采用具备密文完整性保证的 AEAD 方案，以确保服务器无法在不被发现的情况下修改返回的密文载荷。

本文后续章节讨论的可验证性主要针对 ``是否返回了正确且完整的标识集合''，它与密文内容的完整性相互补充。实践中可以将二者组合，以同时覆盖 ``结果集合欺骗'' 与 ``密文篡改'' 两类风险。

\subsection{哈希函数与抗碰撞性}
哈希函数 $\mathsf{H}:\{0,1\}^*\rightarrow\{0,1\}^\ell$ 用于将变长输入映射为固定长度输出。本文主要使用以下安全性质。

\textbf{抗原像}：给定 $y$，找到 $x$ 使得 $\mathsf{H}(x)=y$ 的概率应可忽略。

\textbf{抗二次原像}：给定 $x$，找到 $x'\ne x$ 且 $\mathsf{H}(x')=\mathsf{H}(x)$ 的概率应可忽略。

\textbf{抗碰撞}：找到任意一对 $x\ne x'$ 使得 $\mathsf{H}(x)=\mathsf{H}(x')$ 的概率应可忽略。

在后续章节中，哈希函数主要承担两类职责：其一是构造短标签与索引键，使服务器难以从标签反推出关键词或标识；其二是作为认证承诺的压缩函数，用于构造 Merkle Hash Tree 的内部节点与根值。

\subsection{Merkle Hash Tree}
Merkle Hash Tree 是一种以哈希为基础的认证数据结构，可对集合或序列的内容给出紧凑的完整性承诺，并支持对单个元素的成员性证明。该结构可追溯至 Merkle 的早期工作。\cite{merkle1979}

设有一组叶子值 $v_1,\ldots,v_n$，定义叶子哈希为 $h_i=\mathsf{H}(v_i)$。内部节点由其左右子节点哈希拼接后再哈希得到，即 $h_{u}=\mathsf{H}(h_{\mathsf{left}}\|h_{\mathsf{right}})$。根哈希 $h_{\mathsf{root}}$ 可视为对整个叶子集合的承诺。

\textbf{成员性证明}：给定索引 $i$，服务器可返回从叶子到根路径上每一层的兄弟节点哈希，组成认证路径 $\pi_i$。验证者使用 $v_i$ 与 $\pi_i$ 自底向上重算根哈希，若得到的根值等于已知的 $h_{\mathsf{root}}$，则接受该成员性证明。

Merkle Hash Tree 的证明长度为 $O(\log n)$，验证开销同样为 $O(\log n)$。该性质使其适用于外包场景下的结果可验证增强。本文后续章节将利用其 ``根值承诺加认证路径'' 的机制，为资格检验阶段提供确定性可验证的成员性证明支撑。

\subsection{承诺机制}
承诺机制为 ``先承诺后公开'' 的两阶段协议原语，形式化为三元组 $\mathsf{Com}=(\mathsf{Commit},\mathsf{Open},\mathsf{Verify})$。给定消息 $m$，承诺者使用随机数 $r$ 计算承诺值 $c\leftarrow\mathsf{Commit}(m;r)$ 并发布 $c$。在公开阶段，承诺者发布 $(m,r)$，验证者运行 $\mathsf{Verify}(c,m,r)$ 判断是否接受。

承诺机制通常要求满足两类性质。\textbf{隐藏性}要求在公开之前，$c$ 不应泄露关于 $m$ 的有效信息。\textbf{绑定性}要求承诺者难以找到两组不同的 $(m,r)$ 与 $(m',r')$ 使得对同一 $c$ 验证均通过。经典结果表明可利用伪随机性构造安全的比特承诺协议。\cite{naor1991}

在本文的后续设计中，承诺机制被用于将 ``应当返回的正确结果'' 与服务器的返回行为绑定。直观上，若在更新阶段将某个与正确结果相关的承诺值预先固定下来，则在搜索阶段服务器难以在不被检测的情况下返回与该承诺不一致的结果。如何在不显著增加索引规模与搜索开销的前提下嵌入承诺信息，将在后续章节展开。

\subsection{小结}
本章给出了多用户多关键词 SSE 的系统抽象、威胁假设与基础索引型搜索流程，并分析了 Bloom Filter 在资格检验中的效率价值与可验证性局限，同时整理了后续章节将使用的 PRF、哈希、Merkle Hash Tree 与承诺机制等密码学工具。基于这些准备，后续章节将在既有结构化 SSE 框架上对资格检验与结果返回两个关键环节进行可验证增强设计，并给出相应的安全性分析与开销评估。
